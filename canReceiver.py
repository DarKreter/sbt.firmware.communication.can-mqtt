import can
from can.interface import Bus
import cantools
from CanDecoder import CanDecoder
from CanID_autogenerated import *
from mqtt import MQTT
import time


def canReceiver(bus, args, canDecoder, myMQTT):
    while 1:
        for msg in bus:
            try:
                # Exception with KLS
                if msg.arbitration_id == 0x0CF11E05 or msg.arbitration_id == 0x0CF11F05:

                    KLS_dbc_path = args.dbc_file[:args.dbc_file.rindex(
                        '/')+1] + "KLS.dbc"
                    db = cantools.database.load_file(KLS_dbc_path)
                    frame = db.decode_message(msg.arbitration_id, msg.data)

                # Standard SBT CAN ID
                else:
                    # Decode frame
                    frame = canDecoder.decode_payload(
                        msg.arbitration_id, msg.data)

                    # Get SBT IDs
                sourceIDname = canDecoder.decode_sourceID_name(msg.arbitration_id)
                paramIDname = canDecoder.decode_paramID_name(msg.arbitration_id)

                print("New message from CAN!")
                # Print all signals from frame to MQTT
                for signal in frame:
                    myMQTT.publish(
                        ["SBT", args.thread, sourceIDname, paramIDname, signal], frame[signal])
                    print("Sending to MQTT: SBT/{}/{}/{}/{} = {}".format(args.thread, sourceIDname,
                                                                         paramIDname, signal, frame[signal]))
                print()

            except Exception as e:
                print("Unknown frame: {}#{}".format(
                    msg.arbitration_id, msg.data))
                print("Error: {}".format(e))
                print()


def idle():
    while 1:
        time.sleep(1)
        pass
